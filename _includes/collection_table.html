{% if include.collection == "aotd" %}
  {% assign allapps = site.data["collection"]  uniq | sort: "name" %}
  {% assign random = site.time | date: "%s%N" | modulo: allapps.size %}
  {% assign apps = "" | split: ',' %}
  {% assign apps = apps | push: allapps[random] %}
{% else %}
  {% assign apps = site.data["collection"] | where_exp:"app",
"app.collection contains include.collection" | uniq | sort: "name" %}
{% endif %}
<style>
    ul { padding: 5px; }

    .collection-table-wrapper table li {
        margin-left: 10px !important;
    }

    .collection-table-wrapper table ul li {
        margin-left: 10px !important;
    }

    .collection-table-wrapper {
        display: block !important;
        width: 100% !important;
        max-width: 90vw !important;
        max-height: 80vh !important;
        overflow-x: auto !important;
        overflow-y: auto !important;
        box-sizing: border-box !important;

        overscroll-behavior-x: contain !important;
        overscroll-behavior-y: contain !important;
        scrollbar-gutter: stable both-edges !important;

        -webkit-overflow-scrolling: touch !important;
    }

    /* Default: never show outlines (mouse users wonâ€™t see a ring) */
    .collection-table-wrapper:focus,
    .collection-table-wrapper:focus-visible {
        outline: none !important;
        box-shadow: none !important;
    }

    /* Keyboard-nav mode: show a subtle focus indicator (accessible + not obnoxious) */
    html.kbd-nav .collection-table-wrapper:focus {
        outline: 2px solid rgba(0, 0, 0, 0.22) !important;
        outline-offset: 2px !important;
        border-radius: 6px !important;
    }

    .collection-table-wrapper.is-dragging {
        cursor: grabbing !important;
        user-select: none !important;
    }

    .collection-table-wrapper table {
        width: 100% !important;
        min-width: 850px !important; /* 200 + 150 + 150 + 150 + 200 */
        table-layout: fixed !important;
        border-collapse: collapse !important;
    }

    .collection-table-wrapper th {
        position: sticky !important;
        top: 0 !important;
        background: #f5f5f5 !important;
        white-space: nowrap !important;
        padding: 8px !important;
        z-index: 5 !important;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15) !important;
    }

    .collection-table-wrapper td {
        white-space: nowrap !important;
        padding: 8px !important;
        vertical-align: top !important;
    }

    .collection-table-wrapper td:last-child {
        white-space: normal !important;
    }

    .collection-table-wrapper th:nth-child(1),
    .collection-table-wrapper td:nth-child(1) {
        width: 200px !important;
        min-width: 200px !important;
        max-width: 200px !important;
        white-space: normal !important;
        word-wrap: break-word !important;
        overflow-wrap: break-word !important;
        word-break: break-word !important;
    }

    .collection-table-wrapper th:nth-child(2),
    .collection-table-wrapper td:nth-child(2) {
        width: 150px !important;
        min-width: 150px !important;
        max-width: 150px !important;
        white-space: normal !important;
        word-wrap: break-word !important;
        overflow-wrap: break-word !important;
        word-break: break-word !important;
    }

    .collection-table-wrapper th:nth-child(3),
    .collection-table-wrapper td:nth-child(3) {
        width: 150px !important;
        min-width: 150px !important;
        max-width: 150px !important;
        white-space: normal !important;
        word-wrap: break-word !important;
        overflow-wrap: break-word !important;
        word-break: break-word !important;
    }

    .collection-table-wrapper th:nth-child(4),
    .collection-table-wrapper td:nth-child(4) {
        width: 150px !important;
        min-width: 150px !important;
        max-width: 150px !important;
        white-space: normal !important;
        word-wrap: break-word !important;
        overflow-wrap: break-word !important;
        word-break: break-word !important;
    }

    .collection-table-wrapper th:nth-child(5),
    .collection-table-wrapper td:nth-child(5) {
        width: 200px !important;
        min-width: 200px !important;
        max-width: 200px !important;
        white-space: normal !important;
        word-wrap: break-word !important;
        overflow-wrap: break-word !important;
        word-break: break-word !important;
    }

    @media screen and (max-width: 839px) {
        .collection-table-wrapper {
            border: 1px solid #ddd !important;
            border-radius: 4px !important;
            margin: 1em 0 !important;
        }
    }

    @media screen and (min-width: 840px) {
        .collection-table-wrapper {
            max-width: 65vw !important;
            width: auto !important;
        }
    }
</style>

<div class="collection-table-wrapper" tabindex="0" role="region" aria-label="Collection table" data-wheel-mode="smart">
<table style="font-size: 16px">
  <tr>
    <th>App. URL</th>
    <th>Author</th>
    <th>Reference(s)</th>
    <th>Technology(ies)</th>
    <th>Note(s)</th>
  </tr>
  {% for app in apps %}
  <tr>
    <td>
        <a href="{{ app.url }}">{{ app.name }}</a><br>
        {% if app.badge %}
            <img alt="GitHub stars" src="https://img.shields.io/github/stars/{{ app.badge }}?style=social">
        {% endif %}
    </td>
    <td>
        {{ app.author }}<br>
        {% if app.badge %}
            <img alt="GitHub contributors" src="https://img.shields.io/github/contributors/{{ app.badge }}">
        {% endif %}
    </td>
    <td>
      {% if app.references %}
        <ul>
          {% for ref in app.references %}
            <li><a href="{{ ref.url }}">{{ ref.name | capitalize }}</a></li>
          {% endfor %}
        </ul>
      {% endif %}
    </td>
    <td>
      {% if app.technology %}
        <ul>
          {% for tech in app.technology %}
            <li>{{ tech }}</li>
          {% endfor %}
        </ul>
      {% endif %}
    </td>
    <td>
        {{ app.notes }}<br>
        {% if app.badge %}
            <img alt="GitHub last commit" src="https://img.shields.io/github/last-commit/{{ app.badge }}">
        {% endif %}
    </td>
  </tr>
  {% endfor %}
</table>
</div>

<script>
(() => {
  const WRAPPER_SELECTOR = '.collection-table-wrapper';
  const INTERACTIVE_SELECTOR = 'a, button, input, textarea, select, label, summary, details, [role="button"]';

  function isInteractiveTarget(target) {
    return !!(target && target.closest && target.closest(INTERACTIVE_SELECTOR));
  }

  function setKeyboardNavMode(on) {
    const root = document.documentElement;
    if (on) root.classList.add('kbd-nav');
    else root.classList.remove('kbd-nav');
  }

  function initInputModalityTracker() {
    if (document.documentElement.dataset.kbdNavInit === '1') return;
    document.documentElement.dataset.kbdNavInit = '1';

    window.addEventListener('keydown', (e) => {
      if (e.key === 'Tab') setKeyboardNavMode(true);
    }, true);

    window.addEventListener('pointerdown', () => {
      setKeyboardNavMode(false);
    }, true);
  }

  function initWrapper(wrap) {
    if (wrap.dataset.hscrollInit === '1') return;
    wrap.dataset.hscrollInit = '1';

    if (!wrap.hasAttribute('tabindex')) wrap.setAttribute('tabindex', '0');

    wrap.addEventListener('wheel', (e) => {
      const hasX = wrap.scrollWidth > wrap.clientWidth + 1;
      const hasY = wrap.scrollHeight > wrap.clientHeight + 1;
      if (!hasX && !hasY) return;

      const absX = Math.abs(e.deltaX);
      const absY = Math.abs(e.deltaY);
      const mode = (wrap.getAttribute('data-wheel-mode') || 'smart').toLowerCase();

      if (hasX && absX > absY && absX > 0) {
        e.preventDefault();
        wrap.scrollLeft += e.deltaX;
        return;
      }

      if (hasX && e.shiftKey && absY > 0) {
        e.preventDefault();
        wrap.scrollLeft += e.deltaY;
        return;
      }

      if (hasX && absY > 0) {
        if (mode === 'always') {
          e.preventDefault();
          wrap.scrollLeft += e.deltaY;
          return;
        }

        if (mode === 'edge') {
          const atTop = wrap.scrollTop <= 0;
          const atBottom = wrap.scrollTop + wrap.clientHeight >= wrap.scrollHeight - 1;
          if (!hasY || atTop || atBottom) {
            e.preventDefault();
            wrap.scrollLeft += e.deltaY;
            return;
          }
        }
      }
    }, { passive: false });

    wrap.addEventListener('keydown', (e) => {
      const hasX = wrap.scrollWidth > wrap.clientWidth + 1;
      const hasY = wrap.scrollHeight > wrap.clientHeight + 1;
      if (!hasX && !hasY) return;

      const line = 40;
      const pageX = Math.max(120, Math.floor(wrap.clientWidth * 0.9));
      const pageY = Math.max(120, Math.floor(wrap.clientHeight * 0.9));

      switch (e.key) {
        case 'ArrowLeft':
          if (!hasX) return;
          e.preventDefault();
          wrap.scrollLeft -= line;
          break;
        case 'ArrowRight':
          if (!hasX) return;
          e.preventDefault();
          wrap.scrollLeft += line;
          break;
        case 'Home':
          if (!hasX) return;
          e.preventDefault();
          wrap.scrollLeft = 0;
          break;
        case 'End':
          if (!hasX) return;
          e.preventDefault();
          wrap.scrollLeft = wrap.scrollWidth;
          break;
        case 'PageUp':
          e.preventDefault();
          if (hasX && e.shiftKey) wrap.scrollLeft -= pageX;
          else if (hasY) wrap.scrollTop -= pageY;
          break;
        case 'PageDown':
          e.preventDefault();
          if (hasX && e.shiftKey) wrap.scrollLeft += pageX;
          else if (hasY) wrap.scrollTop += pageY;
          break;
        default:
          break;
      }
    });

    let isPanning = false;
    let startX = 0;
    let startY = 0;
    let startLeft = 0;
    let startTop = 0;
    let pointerId = null;

    wrap.addEventListener('pointerdown', (e) => {
      if (!isInteractiveTarget(e.target) && e.button === 0) {
        try { wrap.focus({ preventScroll: true }); } catch { wrap.focus(); }
      }

      if (isInteractiveTarget(e.target)) return;

      const isMiddle = e.button === 1;
      const isAltLeft = e.button === 0 && e.altKey;

      if (!isMiddle && !isAltLeft) return;

      isPanning = true;
      pointerId = e.pointerId;
      startX = e.clientX;
      startY = e.clientY;
      startLeft = wrap.scrollLeft;
      startTop = wrap.scrollTop;

      wrap.classList.add('is-dragging');
      wrap.setPointerCapture(pointerId);
      e.preventDefault();
    });

    wrap.addEventListener('pointermove', (e) => {
      if (!isPanning || e.pointerId !== pointerId) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      wrap.scrollLeft = startLeft - dx;
      wrap.scrollTop = startTop - dy;
    });

    function endPan() {
      if (!isPanning) return;
      isPanning = false;
      pointerId = null;
      wrap.classList.remove('is-dragging');
    }

    wrap.addEventListener('pointerup', endPan);
    wrap.addEventListener('pointercancel', endPan);
    wrap.addEventListener('lostpointercapture', endPan);
  }

  function initAll() {
    initInputModalityTracker();
    document.querySelectorAll(WRAPPER_SELECTOR).forEach(initWrapper);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAll, { once: true });
  } else {
    initAll();
  }
})();
</script>
